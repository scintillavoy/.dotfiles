#!/usr/bin/env bash

# ------------------------------------------------------------------------------
# Helper functions for checking conditions
# - Functions in this section check whether conditions are satisfied or not.
# - If the check succeeds, it returns 0.
# - Otherwise, it returns some value other than 0.
# ------------------------------------------------------------------------------

check_local_changes() {
  [ "$(git status --porcelain | wc -l)" -eq 0 ] && return 0
  echo "Error: There are local changes in the working tree:"
  git status --porcelain | sed -r "s|^(.*)$|\t\1|g"
  echo "Please commit your changes or stash them first."
  return 1
}

check_remote_branch_exists() {
  local branch_name=$1
  [ "$(git branch --remote --list "$branch_name" | wc -l)" -gt 0 ] && return 0
  echo "Error: Remote branch $branch_name does not exist."
  echo "Aborted."
  return 1
}

check_remote_branch_does_not_exist() {
  local branch_name=$1
  [ "$(git branch --remote --list "$branch_name" | wc -l)" -eq 0 ] && return 0
  echo "Error: Remote branch $branch_name already exists."
  echo "Aborted."
  return 1
}

check_remote_tag_does_not_exist() {
  local remote_name=$1
  local tag_name=$2
  [ "$(git ls-remote --tags "$remote_name" "$tag_name" | wc -l)" -eq 0 ] && return 0
  echo "Error: Tag $tag_name already exists in remote $remote_name."
  echo "Aborted."
  return 1
}

check_merge_conflict() {
  local branch_name=$1
  local flag_name=$2
  [ "$(git ls-files -u "$PROJECT_ROOT_DIR" | wc -l)" -eq 0 ] && return 0
  echo "Error: Merge conflict detected while merging into $branch_name."
  echo "Resolve conflicts and run $SCRIPT_PATH $TARGET_VERSION $DEVELOPMENT_VERSION $flag_name"
  return 1
}

# ------------------------------------------------------------------------------
# Helper functions for Git operations
# ------------------------------------------------------------------------------

change_version() {
  local version=$1
  local change_version_path=$SCRIPT_DIR/change_version
  if [ -n "$CHANGE_VERSION_PATH" ]; then
    change_version_path=$CHANGE_VERSION_PATH
  elif [ -f "$PROJECT_ROOT_DIR/scripts/change_version" ]; then
    change_version_path=$PROJECT_ROOT_DIR/scripts/change_version
  fi
  if [ -f "$change_version_path" ]; then
    source "$change_version_path" "$version"
    git add --all
  else
    echo "Warning: cannot find a script to change version."
  fi
  git commit --allow-empty -m "Change version to $version"
}

merge_into_main() {
  git checkout -B "$MAIN_BRANCH_NAME" "$REMOTE_NAME/$MAIN_BRANCH_NAME"
  git pull --ff-only
  git merge --no-ff --no-edit "$REMOTE_NAME/$BRANCH_PREFIX$TARGET_VERSION"
  check_merge_conflict "$MAIN_BRANCH_NAME" "--continue-from-main"
  local return_value=$?
  [ $return_value -ne 0 ] && exit $return_value
}

merge_into_development() {
  git checkout -B "$BRANCH_PREFIX$TARGET_VERSION" "$REMOTE_NAME/$BRANCH_PREFIX$TARGET_VERSION"
  git pull --ff-only
  change_version "$DEVELOPMENT_VERSION"

  git checkout -B "$DEVELOPMENT_BRANCH_NAME" "$REMOTE_NAME/$DEVELOPMENT_BRANCH_NAME"
  git pull --ff-only
  git merge --no-ff --no-edit "$BRANCH_PREFIX$TARGET_VERSION"
  check_merge_conflict "$DEVELOPMENT_BRANCH_NAME" "--continue-from-development"
  local return_value=$?
  [ $return_value -ne 0 ] && exit $return_value
}

push_to_remote() {
  echo "Pushing to $REMOTE_NAME..."
  git push "$REMOTE_NAME" "$MAIN_BRANCH_NAME" "$DEVELOPMENT_BRANCH_NAME" "$BRANCH_PREFIX$TARGET_VERSION" "v$TARGET_VERSION"
}

# ------------------------------------------------------------------------------
# Start
# ------------------------------------------------------------------------------

start() {
  check_local_changes
  local return_value=$?
  [ $return_value -ne 0 ] && return $return_value

  git fetch "$REMOTE_NAME"

  check_remote_tag_does_not_exist "$REMOTE_NAME" "v$TARGET_VERSION"
  return_value=$?
  [ $return_value -ne 0 ] && return $return_value

  check_remote_branch_exists "$REMOTE_NAME/$BASE_BRANCH"
  return_value=$?
  [ $return_value -ne 0 ] && return $return_value

  check_remote_branch_does_not_exist "$REMOTE_NAME/$BRANCH_PREFIX$TARGET_VERSION"
  return_value=$?
  [ $return_value -ne 0 ] && return $return_value

  git checkout -B "$BRANCH_PREFIX$TARGET_VERSION" "$REMOTE_NAME/$BASE_BRANCH"
  change_version "$TARGET_VERSION"

  echo "Pushing to $REMOTE_NAME..."
  git push -u "$REMOTE_NAME" "$BRANCH_PREFIX$TARGET_VERSION"
  return 0
}

# ------------------------------------------------------------------------------
# Finish
# ------------------------------------------------------------------------------

finish() {
  if [ $# -gt 0 ]; then
    case $1 in
      "--continue-from-main")
        check_merge_conflict "$MAIN_BRANCH_NAME" "--continue-from-main"
        local return_value=$?
        if [ $return_value -ne 0 ]; then
          exit $return_value
        fi
        git commit --no-edit
        merge_into_development
        ;;
      "--continue-from-development")
        check_merge_conflict "$DEVELOPMENT_BRANCH_NAME" "--continue-from-development"
        local return_value=$?
        if [ $return_value -ne 0 ]; then
          exit $return_value
        fi
        git commit --no-edit
        ;;
      *)
        return 2
        ;;
    esac
    push_to_remote
    return 0
  fi

  check_local_changes
  local return_value=$?
  [ $return_value -ne 0 ] && return $return_value

  git fetch "$REMOTE_NAME"

  check_remote_tag_does_not_exist "$REMOTE_NAME" "v$TARGET_VERSION"
  return_value=$?
  [ $return_value -ne 0 ] && return $return_value

  check_remote_branch_exists "$REMOTE_NAME/$MAIN_BRANCH_NAME"
  return_value=$?
  [ $return_value -ne 0 ] && return $return_value

  check_remote_branch_exists "$REMOTE_NAME/$DEVELOPMENT_BRANCH_NAME"
  return_value=$?
  [ $return_value -ne 0 ] && return $return_value

  check_remote_branch_exists "$REMOTE_NAME/$BRANCH_PREFIX$TARGET_VERSION"
  return_value=$?
  [ $return_value -ne 0 ] && return $return_value

  git tag -f "v$TARGET_VERSION" "$REMOTE_NAME/$BRANCH_PREFIX$TARGET_VERSION"
  merge_into_main
  merge_into_development
  push_to_remote
  return 0
}
