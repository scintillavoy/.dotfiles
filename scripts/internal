#!/usr/bin/env bash

# ------------------------------------------------------------------------------
# Constants
# ------------------------------------------------------------------------------

RED="\033[0;31m"
ORANGE="\033[0;33m"
BLUE="\033[0;34m"
NO_COLOR="\033[0m"

# ------------------------------------------------------------------------------
# Helper functions for checking conditions
# - Functions in this section check whether conditions are satisfied or not.
# - If the check succeeds, it returns 0.
# - Otherwise, it returns some value other than 0.
# ------------------------------------------------------------------------------

check_local_changes() {
  [ "$(git status --porcelain | wc -l)" -eq 0 ] && return 0
  printf "%bError: There are local changes in the working tree:%b\n" "${RED}" "${NO_COLOR}"
  git status --porcelain | sed -r "s|^(.*)$|\t\1|g"
  printf "%bPlease commit your changes or stash them first.%b\n" "${RED}" "${NO_COLOR}"
  return 1
}

check_remote_branch_exists() {
  local branch_name=$1
  [ "$(git branch --remote --list "$branch_name" | wc -l)" -gt 0 ] && return 0
  printf "%bError: Remote branch $branch_name does not exist.%b\n" "${RED}" "${NO_COLOR}"
  printf "%bAborted.%b\n" "${RED}" "${NO_COLOR}"
  return 1
}

check_remote_branch_does_not_exist() {
  local branch_name=$1
  [ "$(git branch --remote --list "$branch_name" | wc -l)" -eq 0 ] && return 0
  printf "%bError: Remote branch $branch_name already exists.%b\n" "${RED}" "${NO_COLOR}"
  printf "%bAborted.%b\n" "${RED}" "${NO_COLOR}"
  return 1
}

check_remote_tag_does_not_exist() {
  local remote_name=$1
  local tag_name=$2
  [ "$(git ls-remote --tags "$remote_name" "$tag_name" | wc -l)" -eq 0 ] && return 0
  printf "%bError: Tag $tag_name already exists in remote $remote_name.%b\n" "${RED}" "${NO_COLOR}"
  printf "%bAborted.%b\n" "${RED}" "${NO_COLOR}"
  return 1
}

check_merge_conflict() {
  local branch_name=$1
  local flag_name=$2
  [ "$(git ls-files -u "$PROJECT_ROOT_DIR" | wc -l)" -eq 0 ] && return 0
  printf "%bError: Merge conflict detected while merging into $branch_name.%b\n" "${RED}" "${NO_COLOR}"
  printf "%bResolve conflicts and run $SCRIPT_PATH $TARGET_VERSION $DEVELOPMENT_VERSION $flag_name%b\n" "${RED}" "${NO_COLOR}"
  return 1
}

# ------------------------------------------------------------------------------
# Helper functions for Git operations
# ------------------------------------------------------------------------------

change_version() {
  local version=$1
  local change_version_path=$SCRIPT_DIR/change_version
  if [ -n "$CHANGE_VERSION_PATH" ]; then
    change_version_path=$CHANGE_VERSION_PATH
  elif [ -f "$PROJECT_ROOT_DIR/scripts/change_version" ]; then
    change_version_path=$PROJECT_ROOT_DIR/scripts/change_version
  fi
  if [ -f "$change_version_path" ]; then
    source "$change_version_path" "$version"
    git add --all
  else
    printf "%bWarning: Cannot find a script to change version.%b\n" "${ORANGE}" "${NO_COLOR}"
  fi
  git commit --allow-empty -m "Change version to $version"
}

merge_into_main() {
  git checkout -B "$MAIN_BRANCH_NAME" "$REMOTE_NAME/$MAIN_BRANCH_NAME"
  git pull --ff-only
  git merge --no-ff --no-edit "$REMOTE_NAME/$BRANCH_PREFIX$TARGET_VERSION"
  check_merge_conflict "$MAIN_BRANCH_NAME" "--continue-from-main"
  local return_value=$?
  [ $return_value -ne 0 ] && return $return_value
}

merge_into_development() {
  git checkout -B "$BRANCH_PREFIX$TARGET_VERSION" "$REMOTE_NAME/$BRANCH_PREFIX$TARGET_VERSION"
  git pull --ff-only
  change_version "$DEVELOPMENT_VERSION"

  git checkout -B "$DEVELOPMENT_BRANCH_NAME" "$REMOTE_NAME/$DEVELOPMENT_BRANCH_NAME"
  git pull --ff-only
  git merge --no-ff --no-edit "$BRANCH_PREFIX$TARGET_VERSION"
  check_merge_conflict "$DEVELOPMENT_BRANCH_NAME" "--continue-from-development"
  local return_value=$?
  [ $return_value -ne 0 ] && return $return_value
}

push_to_remote() {
  local arguments=("$@")
  if [ -n "$FORCE" ]; then
    arguments=("$FORCE" "${arguments[@]}")
  fi
  printf "%bPushing to $REMOTE_NAME...%b\n" "${BLUE}" "${NO_COLOR}"
  git push "${arguments[@]}"
}

# ------------------------------------------------------------------------------
# Start
# ------------------------------------------------------------------------------

start() {
  check_local_changes
  local return_value=$?
  [ $return_value -ne 0 ] && return $return_value

  git fetch "$REMOTE_NAME"

  if [ -z "$FORCE" ]; then
    check_remote_tag_does_not_exist "$REMOTE_NAME" "$TAG_PREFIX$TARGET_VERSION"
    return_value=$?
    [ $return_value -ne 0 ] && return $return_value

    check_remote_branch_does_not_exist "$REMOTE_NAME/$BRANCH_PREFIX$TARGET_VERSION"
    return_value=$?
    [ $return_value -ne 0 ] && return $return_value
  fi

  check_remote_branch_exists "$REMOTE_NAME/$BASE_BRANCH_NAME"
  return_value=$?
  if [ $return_value -ne 0 ]; then
    printf "%bHint: The name of the base branch can be overridden by setting an environment variable.%b\n" "${ORANGE}" "${NO_COLOR}"
    printf "%bHint: For example, try 'export BASE_BRANCH_NAME=<base_branch_name>'.%b\n" "${ORANGE}" "${NO_COLOR}"
    return $return_value
  fi

  git checkout -B "$BRANCH_PREFIX$TARGET_VERSION" "$REMOTE_NAME/$BASE_BRANCH_NAME"
  change_version "$TARGET_VERSION"

  local push_arguments=(
    -u
    "$REMOTE_NAME"
    "$BRANCH_PREFIX$TARGET_VERSION"
  )
  push_to_remote "${push_arguments[@]}"
  return 0
}

# ------------------------------------------------------------------------------
# Finish
# ------------------------------------------------------------------------------

finish() {
  local return_value

  if [ -z "$CONTINUE" ]; then
    check_local_changes
    return_value=$?
    [ $return_value -ne 0 ] && return $return_value
  fi

  git fetch "$REMOTE_NAME"

  if [ -z "$FORCE" ]; then
    check_remote_tag_does_not_exist "$REMOTE_NAME" "$TAG_PREFIX$TARGET_VERSION"
    return_value=$?
    [ $return_value -ne 0 ] && return $return_value
  fi

  check_remote_branch_exists "$REMOTE_NAME/$MAIN_BRANCH_NAME"
  return_value=$?
  if [ $return_value -ne 0 ]; then
    printf "%bHint: The name of the main branch can be overridden by setting an environment variable.%b\n" "${ORANGE}" "${NO_COLOR}"
    printf "%bHint: For example, try 'export MAIN_BRANCH_NAME=<main_branch_name>'.%b\n" "${ORANGE}" "${NO_COLOR}"
    return $return_value
  fi

  check_remote_branch_exists "$REMOTE_NAME/$DEVELOPMENT_BRANCH_NAME"
  return_value=$?
  if [ $return_value -ne 0 ]; then
    printf "%bHint: The name of the development branch can be overridden by setting an environment variable.%b\n" "${ORANGE}" "${NO_COLOR}"
    printf "%bHint: For example, try 'export DEVELOPMENT_BRANCH_NAME=<development_branch_name>'.%b\n" "${ORANGE}" "${NO_COLOR}"
    return $return_value
  fi

  check_remote_branch_exists "$REMOTE_NAME/$BRANCH_PREFIX$TARGET_VERSION"
  return_value=$?
  [ $return_value -ne 0 ] && return $return_value

  local push_arguments=(
    "$REMOTE_NAME"
    "$MAIN_BRANCH_NAME"
    "$DEVELOPMENT_BRANCH_NAME"
    "$BRANCH_PREFIX$TARGET_VERSION"
    "$TAG_PREFIX$TARGET_VERSION"
  )

  if [ -n "$CONTINUE" ]; then
    case "$CONTINUE" in
      --continue-from-main)
        check_merge_conflict "$MAIN_BRANCH_NAME" "$CONTINUE"
        return_value=$?
        [ $return_value -ne 0 ] && return $return_value
        git commit --no-edit
        merge_into_development
        return_value=$?
        [ $return_value -ne 0 ] && return $return_value
        ;;
      --continue-from-development)
        check_merge_conflict "$DEVELOPMENT_BRANCH_NAME" "$CONTINUE"
        return_value=$?
        [ $return_value -ne 0 ] && return $return_value
        git commit --no-edit
        ;;
      *)
        return 1
    esac
    push_to_remote "${push_arguments[@]}"
    return 0
  fi

  git tag -f "$TAG_PREFIX$TARGET_VERSION" "$REMOTE_NAME/$BRANCH_PREFIX$TARGET_VERSION"

  merge_into_main
  return_value=$?
  [ $return_value -ne 0 ] && return $return_value

  merge_into_development
  return_value=$?
  [ $return_value -ne 0 ] && return $return_value

  push_to_remote "${push_arguments[@]}"
  return 0
}
